//! Minimal 6×8 pixel font for UI text rendering
//!
//! Supports ASCII 32–126 (space through tilde).
//! Each glyph is stored as 8 bytes, one per row, 6 bits wide (MSB-first).

use super::SCREEN_WIDTH;

/// Draw a string onto a u32 ARGB framebuffer
pub fn draw_text(fb: &mut [u32], x: i32, y: i32, text: &str, color: u32) {
    let mut cx = x;
    for ch in text.chars() {
        draw_char(fb, cx, y, ch, color);
        cx += 6;
    }
}

/// Draw a single character onto the framebuffer
fn draw_char(fb: &mut [u32], x: i32, y: i32, ch: char, color: u32) {
    let glyph: &[u8] = match ch {
        ' '..='~' => {
            let idx = ch as usize - 32;
            &FONT_DATA[idx * 8..idx * 8 + 8]
        }
        // German special characters → extra glyphs appended after ASCII
        '\u{00E4}' => &FONT_EXTRA[0..8],   // ä
        '\u{00F6}' => &FONT_EXTRA[8..16],  // ö
        '\u{00FC}' => &FONT_EXTRA[16..24], // ü
        '\u{00C4}' => &FONT_EXTRA[24..32], // Ä
        '\u{00D6}' => &FONT_EXTRA[32..40], // Ö
        '\u{00DC}' => &FONT_EXTRA[40..48], // Ü
        '\u{00DF}' => &FONT_EXTRA[48..56], // ß
        _ => &FONT_DATA[63 * 8..63 * 8 + 8], // '?' for unknown
    };

    for row in 0..8 {
        let dy = y + row as i32;
        if dy < 0 || dy >= 480 {
            continue;
        }
        let bits = glyph[row];
        for col in 0..6 {
            let dx = x + col as i32;
            if dx < 0 || dx >= SCREEN_WIDTH as i32 {
                continue;
            }
            if (bits >> (7 - col)) & 1 != 0 {
                let offset = dy as usize * SCREEN_WIDTH + dx as usize;
                if offset < fb.len() {
                    fb[offset] = color;
                }
            }
        }
    }
}

/// Draw text with a 1px dark shadow for readability
pub fn draw_text_shadow(fb: &mut [u32], x: i32, y: i32, text: &str, color: u32) {
    draw_text(fb, x + 1, y + 1, text, 0xFF000000); // shadow
    draw_text(fb, x, y, text, color);
}

/// Measure text width in pixels
pub fn text_width(text: &str) -> i32 {
    text.chars().count() as i32 * 6
}

/// Draw a filled rectangle
pub fn draw_rect(fb: &mut [u32], x: i32, y: i32, w: i32, h: i32, color: u32) {
    let a = (color >> 24) & 0xFF;
    let blend = a < 255;
    let sr = ((color >> 16) & 0xFF) as u32;
    let sg = ((color >> 8) & 0xFF) as u32;
    let sb = (color & 0xFF) as u32;
    for dy in 0..h {
        let py = y + dy;
        if py < 0 || py >= 480 {
            continue;
        }
        for dx in 0..w {
            let px = x + dx;
            if px < 0 || px >= SCREEN_WIDTH as i32 {
                continue;
            }
            let offset = py as usize * SCREEN_WIDTH + px as usize;
            if offset < fb.len() {
                if blend {
                    let dst = fb[offset];
                    let dr = ((dst >> 16) & 0xFF) as u32;
                    let dg = ((dst >> 8) & 0xFF) as u32;
                    let db = (dst & 0xFF) as u32;
                    let inv = 255 - a;
                    let r = (sr * a + dr * inv) / 255;
                    let g = (sg * a + dg * inv) / 255;
                    let b = (sb * a + db * inv) / 255;
                    fb[offset] = 0xFF000000 | (r << 16) | (g << 8) | b;
                } else {
                    fb[offset] = color;
                }
            }
        }
    }
}

/// Draw rectangle outline (1px border)
pub fn draw_rect_outline(fb: &mut [u32], x: i32, y: i32, w: i32, h: i32, color: u32) {
    // Top and bottom
    for dx in 0..w {
        set_px(fb, x + dx, y, color);
        set_px(fb, x + dx, y + h - 1, color);
    }
    // Left and right
    for dy in 0..h {
        set_px(fb, x, y + dy, color);
        set_px(fb, x + w - 1, y + dy, color);
    }
}

fn set_px(fb: &mut [u32], x: i32, y: i32, color: u32) {
    if x >= 0 && x < SCREEN_WIDTH as i32 && y >= 0 && y < 480 {
        let offset = y as usize * SCREEN_WIDTH + x as usize;
        if offset < fb.len() {
            fb[offset] = color;
        }
    }
}

// ============================================================================
// 6×8 Font data — ASCII 32–126, 8 bytes per glyph
// Based on the classic IBM PC CGA/EGA font style
// ============================================================================
#[rustfmt::skip]
static FONT_DATA: &[u8] = &[
    // 32: ' ' (space)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 33: '!'
    0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x20, 0x00,
    // 34: '"'
    0x50, 0x50, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 35: '#'
    0x50, 0x50, 0xF8, 0x50, 0xF8, 0x50, 0x50, 0x00,
    // 36: '$'
    0x20, 0x78, 0xA0, 0x70, 0x28, 0xF0, 0x20, 0x00,
    // 37: '%'
    0xC0, 0xC8, 0x10, 0x20, 0x40, 0x98, 0x18, 0x00,
    // 38: '&'
    0x40, 0xA0, 0xA0, 0x40, 0xA8, 0x90, 0x68, 0x00,
    // 39: '''
    0x20, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 40: '('
    0x10, 0x20, 0x40, 0x40, 0x40, 0x20, 0x10, 0x00,
    // 41: ')'
    0x40, 0x20, 0x10, 0x10, 0x10, 0x20, 0x40, 0x00,
    // 42: '*'
    0x00, 0x20, 0xA8, 0x70, 0xA8, 0x20, 0x00, 0x00,
    // 43: '+'
    0x00, 0x20, 0x20, 0xF8, 0x20, 0x20, 0x00, 0x00,
    // 44: ','
    0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x40,
    // 45: '-'
    0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00,
    // 46: '.'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
    // 47: '/'
    0x00, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00,
    // 48: '0'
    0x70, 0x88, 0x98, 0xA8, 0xC8, 0x88, 0x70, 0x00,
    // 49: '1'
    0x20, 0x60, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
    // 50: '2'
    0x70, 0x88, 0x08, 0x10, 0x20, 0x40, 0xF8, 0x00,
    // 51: '3'
    0xF8, 0x10, 0x20, 0x10, 0x08, 0x88, 0x70, 0x00,
    // 52: '4'
    0x10, 0x30, 0x50, 0x90, 0xF8, 0x10, 0x10, 0x00,
    // 53: '5'
    0xF8, 0x80, 0xF0, 0x08, 0x08, 0x88, 0x70, 0x00,
    // 54: '6'
    0x30, 0x40, 0x80, 0xF0, 0x88, 0x88, 0x70, 0x00,
    // 55: '7'
    0xF8, 0x08, 0x10, 0x20, 0x40, 0x40, 0x40, 0x00,
    // 56: '8'
    0x70, 0x88, 0x88, 0x70, 0x88, 0x88, 0x70, 0x00,
    // 57: '9'
    0x70, 0x88, 0x88, 0x78, 0x08, 0x10, 0x60, 0x00,
    // 58: ':'
    0x00, 0x00, 0x20, 0x00, 0x00, 0x20, 0x00, 0x00,
    // 59: ';'
    0x00, 0x00, 0x20, 0x00, 0x00, 0x20, 0x20, 0x40,
    // 60: '<'
    0x08, 0x10, 0x20, 0x40, 0x20, 0x10, 0x08, 0x00,
    // 61: '='
    0x00, 0x00, 0xF8, 0x00, 0xF8, 0x00, 0x00, 0x00,
    // 62: '>'
    0x40, 0x20, 0x10, 0x08, 0x10, 0x20, 0x40, 0x00,
    // 63: '?'
    0x70, 0x88, 0x08, 0x10, 0x20, 0x00, 0x20, 0x00,
    // 64: '@'
    0x70, 0x88, 0xB8, 0xA8, 0xB8, 0x80, 0x70, 0x00,
    // 65: 'A'
    0x70, 0x88, 0x88, 0xF8, 0x88, 0x88, 0x88, 0x00,
    // 66: 'B'
    0xF0, 0x88, 0x88, 0xF0, 0x88, 0x88, 0xF0, 0x00,
    // 67: 'C'
    0x70, 0x88, 0x80, 0x80, 0x80, 0x88, 0x70, 0x00,
    // 68: 'D'
    0xE0, 0x90, 0x88, 0x88, 0x88, 0x90, 0xE0, 0x00,
    // 69: 'E'
    0xF8, 0x80, 0x80, 0xF0, 0x80, 0x80, 0xF8, 0x00,
    // 70: 'F'
    0xF8, 0x80, 0x80, 0xF0, 0x80, 0x80, 0x80, 0x00,
    // 71: 'G'
    0x70, 0x88, 0x80, 0xB8, 0x88, 0x88, 0x78, 0x00,
    // 72: 'H'
    0x88, 0x88, 0x88, 0xF8, 0x88, 0x88, 0x88, 0x00,
    // 73: 'I'
    0x70, 0x20, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
    // 74: 'J'
    0x38, 0x10, 0x10, 0x10, 0x10, 0x90, 0x60, 0x00,
    // 75: 'K'
    0x88, 0x90, 0xA0, 0xC0, 0xA0, 0x90, 0x88, 0x00,
    // 76: 'L'
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xF8, 0x00,
    // 77: 'M'
    0x88, 0xD8, 0xA8, 0xA8, 0x88, 0x88, 0x88, 0x00,
    // 78: 'N'
    0x88, 0x88, 0xC8, 0xA8, 0x98, 0x88, 0x88, 0x00,
    // 79: 'O'
    0x70, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
    // 80: 'P'
    0xF0, 0x88, 0x88, 0xF0, 0x80, 0x80, 0x80, 0x00,
    // 81: 'Q'
    0x70, 0x88, 0x88, 0x88, 0xA8, 0x90, 0x68, 0x00,
    // 82: 'R'
    0xF0, 0x88, 0x88, 0xF0, 0xA0, 0x90, 0x88, 0x00,
    // 83: 'S'
    0x78, 0x80, 0x80, 0x70, 0x08, 0x08, 0xF0, 0x00,
    // 84: 'T'
    0xF8, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
    // 85: 'U'
    0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
    // 86: 'V'
    0x88, 0x88, 0x88, 0x88, 0x88, 0x50, 0x20, 0x00,
    // 87: 'W'
    0x88, 0x88, 0x88, 0xA8, 0xA8, 0xD8, 0x88, 0x00,
    // 88: 'X'
    0x88, 0x88, 0x50, 0x20, 0x50, 0x88, 0x88, 0x00,
    // 89: 'Y'
    0x88, 0x88, 0x50, 0x20, 0x20, 0x20, 0x20, 0x00,
    // 90: 'Z'
    0xF8, 0x08, 0x10, 0x20, 0x40, 0x80, 0xF8, 0x00,
    // 91: '['
    0x70, 0x40, 0x40, 0x40, 0x40, 0x40, 0x70, 0x00,
    // 92: '\'
    0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x00, 0x00,
    // 93: ']'
    0x70, 0x10, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00,
    // 94: '^'
    0x20, 0x50, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 95: '_'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x00,
    // 96: '`'
    0x40, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 97: 'a'
    0x00, 0x00, 0x70, 0x08, 0x78, 0x88, 0x78, 0x00,
    // 98: 'b'
    0x80, 0x80, 0xB0, 0xC8, 0x88, 0xC8, 0xB0, 0x00,
    // 99: 'c'
    0x00, 0x00, 0x70, 0x80, 0x80, 0x88, 0x70, 0x00,
    // 100: 'd'
    0x08, 0x08, 0x68, 0x98, 0x88, 0x98, 0x68, 0x00,
    // 101: 'e'
    0x00, 0x00, 0x70, 0x88, 0xF8, 0x80, 0x70, 0x00,
    // 102: 'f'
    0x30, 0x48, 0x40, 0xE0, 0x40, 0x40, 0x40, 0x00,
    // 103: 'g'
    0x00, 0x00, 0x68, 0x98, 0x98, 0x68, 0x08, 0x70,
    // 104: 'h'
    0x80, 0x80, 0xB0, 0xC8, 0x88, 0x88, 0x88, 0x00,
    // 105: 'i'
    0x20, 0x00, 0x60, 0x20, 0x20, 0x20, 0x70, 0x00,
    // 106: 'j'
    0x10, 0x00, 0x30, 0x10, 0x10, 0x10, 0x90, 0x60,
    // 107: 'k'
    0x80, 0x80, 0x90, 0xA0, 0xC0, 0xA0, 0x90, 0x00,
    // 108: 'l'
    0x60, 0x20, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00,
    // 109: 'm'
    0x00, 0x00, 0xD0, 0xA8, 0xA8, 0xA8, 0xA8, 0x00,
    // 110: 'n'
    0x00, 0x00, 0xB0, 0xC8, 0x88, 0x88, 0x88, 0x00,
    // 111: 'o'
    0x00, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00,
    // 112: 'p'
    0x00, 0x00, 0xB0, 0xC8, 0xC8, 0xB0, 0x80, 0x80,
    // 113: 'q'
    0x00, 0x00, 0x68, 0x98, 0x98, 0x68, 0x08, 0x08,
    // 114: 'r'
    0x00, 0x00, 0xB0, 0xC8, 0x80, 0x80, 0x80, 0x00,
    // 115: 's'
    0x00, 0x00, 0x78, 0x80, 0x70, 0x08, 0xF0, 0x00,
    // 116: 't'
    0x40, 0x40, 0xE0, 0x40, 0x40, 0x48, 0x30, 0x00,
    // 117: 'u'
    0x00, 0x00, 0x88, 0x88, 0x88, 0x98, 0x68, 0x00,
    // 118: 'v'
    0x00, 0x00, 0x88, 0x88, 0x88, 0x50, 0x20, 0x00,
    // 119: 'w'
    0x00, 0x00, 0x88, 0x88, 0xA8, 0xA8, 0x50, 0x00,
    // 120: 'x'
    0x00, 0x00, 0x88, 0x50, 0x20, 0x50, 0x88, 0x00,
    // 121: 'y'
    0x00, 0x00, 0x88, 0x88, 0x98, 0x68, 0x08, 0x70,
    // 122: 'z'
    0x00, 0x00, 0xF8, 0x10, 0x20, 0x40, 0xF8, 0x00,
    // 123: '{'
    0x18, 0x20, 0x20, 0xC0, 0x20, 0x20, 0x18, 0x00,
    // 124: '|'
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
    // 125: '}'
    0xC0, 0x20, 0x20, 0x18, 0x20, 0x20, 0xC0, 0x00,
    // 126: '~'
    0x00, 0x00, 0x40, 0xA8, 0x10, 0x00, 0x00, 0x00,
];

// ============================================================================
// Extra glyphs for German characters: ä ö ü Ä Ö Ü ß
// 6×8 pixel bitmaps, same format as FONT_DATA
// ============================================================================
#[rustfmt::skip]
static FONT_EXTRA: &[u8] = &[
    // ä (a with diaeresis)
    0x50, 0x00, 0x70, 0x08, 0x78, 0x88, 0x78, 0x00,
    // ö (o with diaeresis)
    0x50, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00,
    // ü (u with diaeresis)
    0x50, 0x00, 0x88, 0x88, 0x88, 0x98, 0x68, 0x00,
    // Ä (A with diaeresis)
    0x50, 0x00, 0x70, 0x88, 0xF8, 0x88, 0x88, 0x00,
    // Ö (O with diaeresis)
    0x50, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x00,
    // Ü (U with diaeresis)
    0x50, 0x00, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00,
    // ß (sharp s / Eszett)
    0x70, 0x88, 0x90, 0xA0, 0x90, 0x88, 0xB0, 0x00,
];
